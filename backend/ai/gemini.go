package ai

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/malharg/strategic-insight-analyst/backend/config"
	"github.com/malharg/strategic-insight-analyst/backend/database"
)

const geminiAPIURL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key="

type GeminiRequest struct {
	Contents []Content `json:"contents"`
}

type Content struct {
	Parts []Part `json:"parts"`
}

type Part struct {
	Text string `json:"text"`
}

type GeminiResponse struct {
	Candidates []struct {
		Content struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
			Role string `json:"role"`
		} `json:"content"`
	} `json:"candidates"`
}

func GenerateInsight(ctx context.Context, docID, userQuery string) (string, error) {
	// 1. Retrieve all chunks for the given document ID from the database
	rows, err := database.DB.QueryContext(ctx, "SELECT content FROM document_chunks WHERE document_id = ? ORDER BY chunk_index ASC", docID)
	if err != nil {
		return "", fmt.Errorf("could not query document chunks: %w", err)
	}
	defer rows.Close()

	var documentContext strings.Builder
	var chunkCount int
	for rows.Next() {
		var content string
		if err := rows.Scan(&content); err != nil {
			return "", fmt.Errorf("could not scan chunk content: %w", err)
		}
		documentContext.WriteString(content)
		documentContext.WriteString("\n\n")
		chunkCount++
	}
	if err := rows.Err(); err != nil {
		return "", fmt.Errorf("error iterating over chunks: %w", err)
	}
	// =================================================================
	// DEBUG LOG
	log.Printf("DEBUG: Retrieved %d chunks for document ID %s. Total context size: %d chars.", chunkCount, docID, len(documentContext.String()))
	// =================================================================

	// 2.  prompt
	prompt := fmt.Sprintf(`
		You are a Strategic Insight Analyst. Your task is to provide clear, concise, and actionable insights based ONLY on the provided business document context.
		If the information is not in the text, state that the information is not available in the document. Do not make up information.

		DOCUMENT CONTEXT:
		---
		%s
		---

		USER QUERY:
		"%s"

		YOUR ANALYSIS:
	`, documentContext.String(), userQuery)

	// 3. Call the Gemini API
	reqBody := GeminiRequest{
		Contents: []Content{
			{Parts: []Part{{Text: prompt}}},
		},
	}
	reqBytes, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("could not marshal request body: %w", err)
	}

	fullURL := geminiAPIURL + config.AppConfig.GeminiAPIKey
	req, err := http.NewRequestWithContext(ctx, "POST", fullURL, bytes.NewBuffer(reqBytes))
	if err != nil {
		return "", fmt.Errorf("could not create http request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: time.Second * 60}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to call Gemini API: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("could not read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		log.Printf("Gemini API Error: %s", string(respBody))
		return "", fmt.Errorf("gemini API returned non-200 status: %d", resp.StatusCode)
	}

	// 4. Parse the response and extract the text
	var geminiResp GeminiResponse
	if err := json.Unmarshal(respBody, &geminiResp); err != nil {
		return "", fmt.Errorf("could not unmarshal response: %w", err)
	}

	if len(geminiResp.Candidates) > 0 && len(geminiResp.Candidates[0].Content.Parts) > 0 {
		return geminiResp.Candidates[0].Content.Parts[0].Text, nil
	}

	return "No response generated by the AI.", nil
}
